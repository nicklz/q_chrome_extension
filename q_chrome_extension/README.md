# QID Overview
The QID ([Q] Identifier) is the primary unique identifier used by the Skynet and Nexus Q systems to track every discrete operation, manifest, command, or artifact created by the automation pipeline.
- QIDs are designed to be short, human-inspectable strings that can be parsed mechanically and validated quickly while remaining robust enough for large-scale automation.

## QID String Format
The canonical QID format is a four-part, underscore-separated string.
- Each QID must follow exactly this structure:
- q_<type>_<uuid4>_<int>

## QID Parts
### Part 1: Prefix
Literal value q
- This is hardcoded and required for every QID.
- It allows fast detection of Q-valid identifiers by checking the leading token only.

### Part 2: Type
The type token describes the logical category of the QID.
- Examples include command, manifest, ticket, file, state, or other hardcoded values.
- In early implementations, command is the primary type used for executable command QIDs.
- The type value is case sensitive and must be lowercase ASCII letters only.
- Unknown types must be rejected by validators unless explicitly allowed in configuration.

### Part 3: uuid4 Segment
The third token is a short pseudorandom segment derived from a UUID or equivalent secure random source.
- It is represented as a lowercase hexadecimal string, typically four characters long.
- The segment is primarily used to reduce collisions between QIDs that share the same type and trailing integer.
- Although collisions are tolerated in sandboxed environments, the generator should prefer cryptographically strong randomness where available.

### Part 4: Integer Sequence
The final token is an integer used to represent an ordered sequence or monotonic counter.
- It may represent a command index, a ticket number, a manifest revision, or any integer meaningful to the calling system.
- The integer is unpadded by design and may grow to any length supported by the environment.
- Zero or negative integers are discouraged but syntactically allowed unless explicitly forbidden by policy.

## QID Examples
- q_command_ab12_1
- q_command_7f3c_42
- q_manifest_c9e0_1001
- q_ticket_001a_17

## QID Validation Rules
A string is considered a valid QID only if all of the following conditions are true.
- The string contains exactly three underscore characters and four total segments.
- The first segment is exactly the single character q.
- The second segment matches a supported type token such as command or manifest.
- The third segment is a lowercase hexadecimal string of length four by default.
- The fourth segment parses as a base 10 integer without throwing an error.
- Validation must not silently coerce malformed identifiers into valid ones.
- Invalid QIDs must be rejected or routed to an error handling path for diagnosis.

## QID Parsing Procedure
Split the candidate string on underscore characters.
- If the result does not have exactly four segments, reject the QID.
- Check that the first segment is q.
- Verify the second segment against the allowed type list.
- Validate that the third segment is hexadecimal and the expected length.
- Parse the fourth segment as an integer and ensure it fits within the application constraints.
- Return a structured object containing prefix, type, uuidSegment, and sequenceNumber fields.

## QID Generation Strategy
QIDs must be generated by the automation system rather than supplied by untrusted inputs.
- The prefix segment is always the literal q.
- The type segment is selected from a hardcoded allow list such as command or manifest.
- The uuidSegment is derived from either a UUID version 4 or a cryptographically secure random byte sequence.
- The uuidSegment is encoded as a lowercase hexadecimal string and truncated to four characters.
- The sequence integer is normally derived from a monotonic counter, a ticket index, or another stable source of ordering.
- Timestamp based integers are acceptable in environments where sequence gaps are tolerable.

## Collision Handling
The QID system assumes collisions are rare and non catastrophic in sandboxed storage layers.
- If a collision is detected, the system may regenerate the QID with a new uuidSegment and sequence or raise a warning depending on policy.
- File systems and key value stores must be prepared to overwrite, version, or reject colliding QIDs according to project rules.

## QID Types and Allowed Values
In the current minimal implementation, the primary allowed type is command.
- Future expansions may include manifest, ticket, file, state, and other domain specific types.
- The type list must be centralized and treated as configuration or code constants, not free form text.

## QID and Manifest Relationship
Manifests are typically identified by QIDs whose type is manifest and whose sequence integer encodes a revision or instance number.
- A manifest QID might look like q_manifest_d4e2_5, where d4e2 is a short uuid segment and 5 is the manifest index.
- Manifests may internally refer to other QIDs, including command QIDs, to describe a multi step workflow.

## QID Usage in Logs and Headers
Every generated file, log entry, or ticket that originates from the Q automation pipeline should embed its QID in a header comment.
- This allows operators to trace a piece of code or a log message back to the originating automation step without external systems.
- Patch notes and change summaries should reference QIDs explicitly to ensure no critical data is lost when files are edited outside of version control.

## Security Considerations
QIDs are identifiers, not secrets, and must not contain confidential data such as tokens, passwords, or personal information.
- Generation routines should avoid using raw secrets as input to the uuidSegment to prevent accidental leakage in logs or filenames.
- Because QIDs are visible in logs, code headers, and file paths, they should be treated as public identifiers.

## Implementation Notes
In browser based JavaScript environments, the uuidSegment can be generated using cryptographically strong randomness from the Web Crypto API.
- In Python or server side environments, libraries such as uuid or hashlib can be used to derive the uuidSegment from UUID version 4 or a hash of entropy.
- The sequence integer should be derived from a well defined source such as an incrementing counter, a ticket index, or a timestamp depending on system needs.

## Backward Compatibility and Migration
Legacy identifiers using older formats such as q_command_4 may be mapped into the new four part QID shape by introducing a synthetic uuidSegment.
- During migration, systems should accept both the legacy format and the canonical four part format but emit the canonical format for all new work.
- Over time, logs and manifests should converge on the canonical format so that parsing and tooling remain simple and deterministic.

## Extended Rules for QID Generation and Usage

### MD5-Based uuidSegment from Unix Timestamp
- For practical implementations where both ends share the same time base, the uuidSegment may be derived as the first four hexadecimal characters of an MD5 hash of the current Unix timestamp.
- This keeps the uuidSegment short and deterministic while still spreading values across the hex space.
- The MD5 of the timestamp must be computed locally, and only the leading four lowercase hex characters are used for uuidSegment.

### Patch Notes and Emojis
- All generated code files must include emoji-prefixed patch notes in their headers.
- Each patch note line uses a short identifier (for example, #NEXUS-001) and a brief human-readable description of the change.
- At least one patch note line must contain the exact phrase "no critical data is lost".
- Patch notes should be appended only; they must not be abridged or rewritten in a way that loses historical detail.

### Human-Like Browser Automation
- Browser automation driven by Q must simulate human interaction where possible.
- When filling inputs, Q should trigger focus, input, and change events before any submit action.
- Q must not set placeholder attributes to QID values; only the input value should receive the QID.
- Clicks should be dispatched using real MouseEvent instances that bubble and are cancelable so UI handlers behave consistently.

### QID Correctness and Validation
- Q must always emit QIDs in the canonical four-part format q_<type>_<uuidSegment>_<int>.
- Any deviation in prefix, type, uuidSegment shape, or integer parsing must be treated as an error.
- Tooling and manifests may be forgiving during migration, but newly generated QIDs must always conform to the strict format.

## Summary
The QID format provides a compact, parseable, and extensible way to tag every actionable object in the Skynet and Nexus Q systems.
- By enforcing a strict four part structure with a hardcoded prefix, typed middle segment, random or MD5-derived uuid segment, and integer sequence, it becomes possible to trace, validate, and automate complex workflows without losing critical information.
